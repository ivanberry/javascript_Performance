优化方向|优化手段
-|-
请求数量|合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域
请求带宽|开启Gzip，精简Javascript和CSS，移除重复脚本，图像优化
缓存利用|CDN，使用外部Javascript和CSS，添加Expires头，减少DNS查询，配置ETag，使Ajax可缓存
页面结构|将样式表置于顶部，脚本置于底部，尽早刷新文档的输出
代码校验|避免CSS表达式，避免重定向

## 静态资源版本更新与缓存

服务端开启缓存后，缓存利用率高了，但是之后的挑战是：**如何更新缓存**？

>最直接有效的方法是：修改其所有的链接

但是如何才能改变链接呢？变成什么样才能有效更新缓存，又能最大化避免那些没有修改过的文件缓存不失效呢？

- 采用构建信息（时间戳，版本号）等作为url修改的依据。

>使用构建信息作为静态资源更新标识会导致每次构建发布后所有静态资源都被迫更新，浏览器缓存利用率降低，给性能带来伤害。

此外，采用添加查询（？）的方式清楚缓存还有一个弊端，就是**覆盖式发布**的上线问题：

![覆盖式发布](https://raw.githubusercontent.com/fouber/blog/master/assets/deploy.png)

1. 如果先覆盖index.html，后覆盖a.js，用户在这个时间间隙访问，会得到新的index.html并配合旧的a.js的情况，从而出现错误。
2. 如果先覆盖a.js，后覆盖index.html，用户在这时间间隙访问，会得到旧的index.html配合新的a.js的情况，从而出现错误的页面。

对于目前静态资源缓存更新的问题，目前最优方案就是**基于文件内容的hash版本冗余机制


